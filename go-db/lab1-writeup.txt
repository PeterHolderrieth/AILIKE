Lab1 Writeup
Tally Portnoi

********************************Changes to API********************************

- I added a new interface for BufferPoolKey. The pageKey method of DBFile interface must now return a BufferPoolKey rather than just the “any” type. The only method the BufferPoolKey interface has right now is getFileName, which I ended up not using in Lab1. However, this method on a BufferPoolKey could be used to get all the cached pages within the BufferPool for a given file, which could be useful (see below). The HeapFilePageKey type implements the BufferPoolKey interface. I wanted the BufferPoolKey interface to be separate from the HeapFilePageKey type because this allows other storage types to define their own key types.
- I added a flushPage method to the Page interface as a convenience. This allowed me to avoid having to repeatedly do something like page.filePointer.flushPage(&page) which often involved wrestling page pointers into the right type (Page vs. heapPage). I figured it was a valid method to add to the Page interface since it is generic; other storage types could support this.
- I added the numOpenSlots method to the Page interface, which returns the number of open slots in that page. Adding this method to the Page interface allowed me to implement my eviction strategy for BufferPool (see below). I think numOpenSlots is generic enough to be extended to other types of pages. In the event that numOpenSlots is not generic enough, I could modify my design to use a related method such as isFull, which would simply return whether or not there is any space on the page.

********************************Design Decisions********************************

- Eviction Strategy: The primary design decision I made in this lab was to evict pages based on the number of empty slots they had. I evicted the page with least number of empty slots. This eviction strategy optimizes for being able to do quick writes. Since iterating through a table involves a full table scan (and therefore swapping out pages in BufferPool) anyway, it seemed reasonable to optimize for leaving pages in BufferPool that are ready to accept writes. I also chose this strategy for it’s simplicity.  It worked well for the types of tests we had in lab1, which involved a lot of successive writes. This strategy also works well for an unordered storage format.
- Storing pageNo vs. offset in the heapPage struct and HeapFilePageKey: I was originally thinking about having heapFile keep track of it’s offset within the heapFile, rather than just it’s page number. One benefit of maintaining the offset, is that this allows more flexibility down the line to support variable page sizes. However, it was much simpler to use the pageNo, especially for this lab, so I ended up going with that design. Storing the pageNo within the heapPage was helpful because it made it easy to generate record IDs for tuples. 
- I added a method to BufferPool called hasPageCached which checks if BufferPool has a given page number cached for a given DBFile. This allowed me to write a more efficient implementation for the heapFile.getPageForInsert method, which is in turn used by heapFile.insertTuple method. Rather than simply iterating over all pages and trying to insert into them, I can now first try to insert into a cached pages. This offers significant speed up. A possible improvement would be to add a method to BufferPool that returns all the cached pages for a given DBFile; this would allow me to avoid having to iterate over all the pages in the file and checking if they are cached one by one. Instead, I would be able to iterate over all the cached pages directly. I originally put the getPageForInsert method on BufferPool since this made it easy to iterate over cached pages; however, I realized that other storage formats may have other logic for selecting pages for insert, so I moved getPageForInsert to the HeapFile.

********************************Incomplete/Missing Parts********************************

- One way I could improve my lab is through better testing. There are many cases that I don’t test (some are indicated in the code, though most aren’t). I could also add tests to make sure that the expected error codes are returned; a utility function for checking if I got the expected error code would be helpful.
- As mentioned above, I could improve my implementation of getPageForInsert by adding a method to BufferPool that returns all cached pages for a given file.

************************************My Lab1 Experience************************************

- I had a lot of fun with Lab1!  I probably spent around 20 hours on it. I thought the lab was well thought out and definitely helped me learn. There for a few minor things that could have made the lab a smoother experience. For example, it was annoying having to wrangle the pointers, and I am wondering if the interfaces could be adjusted to minimize this. Furthermore, there seemed to be a lot of inconsistencies between capitalization between files which was a little distracting. For example, some types in tuple.go are capitalized attributes while the HeapPage type has lower-cased attributes; heapPage is lowercase, while HeapFile is capitalized. It would be nice if these could be made more consistent (or maybe I am just not understanding the convention). I am also wondering if there is a way to make the tests a bit more unit-testy. It was a little frustrating that I couldn't run many of the tests until I had a basically complete implementation of all the methods, but I understand this is difficult given the way the HeapFile and BufferPool interact.
