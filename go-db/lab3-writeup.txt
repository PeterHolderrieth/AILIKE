Lab3 Writeup
Tally Portnoi

******************************Deadlock Detection and Removal ******************************

I chose to detect deadlock using cycle detection rather than prevent deadlock using a global ordering of transactions (such as a WAIT-DIE or WOUND-WAIT scheme). A benefit of using cycle detection compared to one of these schemes is that no transactions are aborted unnecessarily; a transaction is only aborted if it is in a cycle. A drawback of using cycle detection is the overhead of maintaining the wait-for graph and checking for cycles periodically.

I implemented cycle detection in my checkTransactionInCycle method; this method performs a depth-first search through the wait-for graph starting at the given transaction by making recursive calls to _checkPathInCycle. When I first implemented cycle detection, I returned true whenever I detected any cycle. However, I realized that it is possible for a transaction to be blocked on a cycle even if that transaction is not participating in the cycle. My original implementation unnecessarily aborted transactions that may have succeeded if the deadlock-causing cycle was removed. To fix this, I changed my implementation to return true only if the transaction was actually participating in the cycle; I did this by checking if the next node in the graph is the same as the first node on the given path, rather than simply checking if the next node is present in the path. This change prevented transactions from getting aborted unnecessarily. To enable this change, I also needed to keep track of "visited" nodes; otherwise I could get stuck in a cycle that the root node was not participating in. Another thing that was tricky about my implementation  was making sure that my code correctly handled "exclusive lock reservations" (which I talk about in more detail below).

I check for deadlocks using checkTransactionInCycle every few unsuccessful attempts to acquire a lock. If the given transaction is in a cycle, I (optionally) abort the transaction and return a DeadlockError. If I use the "exclusive lock reservation" strategy, I am able to pass all the tests while relying only on testing code to abort transactions. Without the "exclusive lock reservation" strategy, I need to call AbortTransaction and sleep for a few milliseconds before returning the error in order to pass the TestFiveThreads test.

******************************Exclusive Lock Reservations******************************

In order to reduce lock contention, I allow transactions to "reserve" exclusive locks on pages. I had this idea when I was trying to pass all the tests while only relying on the testing code to abort and retry transactions; however, I was unable to pass the TestFiveThreads test because there was too much lock contention. I observed that transactions were blocked indefinitely when trying to acquire exclusive locks because there were always new transactions reading the page. This gave me the idea to allow transactions to "reserve" exclusive locks on pages before all other transactions let go of their shared locks. This "reservation" prevents other transactions from acquiring new shared locks on the page until the exclusive lock is released; however, existing transactions that already hold a shared lock on the page are able to finish reading the page and commit. The transaction with the "exclusive lock reservation" does not modify the page until all other transactions with shared locks release their shared locks; at this point, the exclusive lock is considered fully "granted" and the transaction is able to modify the page. This strategy successfully reduced lock contention, allowing me to pass all the tests even though I did not call AbortTransaction. To see this, you can run my code with "ALLOW_RESERVATIONS" set to true and "ABORT_TRANSACTIONS" set to false.

******************************Modifying HeapFile******************************
Making HeapFile safe for concurrent use ended up being simple. I originally started using mutexes to protect the pageFull map from concurrent access, but I realized that instead I could just swap out the plain Go map with a sync.Map. This change prevents multiple threads from simultaneously reading/writing the pageFull map. From reading the golang documentation, I am not sure if using sync.Map will result in more or less lock contention compared to using a plain Go map with mutexes, but I decided to use sync.Map because it made my code simpler and easier to read.

I originally thought I would need to use mutexes to make sure that inserts/deletes and the corresponding updates to the pageFull map happened atomically. However, I realized that page-level locking would prevent multiple transactions from over-writing the same slot in the pageFull map since each slot corresponds to one page and only one transaction can hold an exclusive lock for a page at a time. Therefore I did not need an additional mutex.

I also needed to modify my getPageForInsert method to make it safe for concurrent use. Since multiple transactions might attempt to create the same page, I added a call to bufPool.GetPage before attempting to create a new page. This call serves two purposes: 1. it lets the transaction check if another transaction has already created the page and re-use that page if it still has space and 2. it lets the transaction acquire an exclusive lock on the page before creating it (the lock is granted based on page number). If the page was already created and is already full, then I retry the entire getPageForInsert logic.

******************************Lab3 Experience******************************
I spent around 15 hours on this lab, and had a lot of fun working on it. The main thing that took a long time was implementing the "exclusive lock reservation" strategy because I was not able to pass the TestFiveThreads test without it. I later figured out how to pass the tests by calling AbortTransaction within the buffer pool when I detected deadlock, but at that point I was already committed to figuring out how to make the reservation strategy work.